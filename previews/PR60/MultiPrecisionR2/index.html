<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MutiPrecisionR2 · MultiPrecisionR2.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="/MultiPrecisionR2/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MultiPrecisionR2.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultiPrecisionR2.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MutiPrecisionR2</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MutiPrecisionR2</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/MultiPrecisionR2/blob/main/docs/src/MultiPrecisionR2.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MutiPrecisionR2"><a class="docs-heading-anchor" href="#MutiPrecisionR2">MutiPrecisionR2</a><a id="MutiPrecisionR2-1"></a><a class="docs-heading-anchor-permalink" href="#MutiPrecisionR2" title="Permalink"></a></h1><p><code>MutliPrecisionR2.jl</code> implements MPR2 (Multi-Precision Quadratic Regularization) algorithm, a multiple floating point precision (or formats) adaptation of the Quadratic Regularization (R2) algorithm. MPR2 is designed to solve unconstrained minimization problems</p><p class="math-container">\[\min f(x)\]</p><p>,</p><p>with <span>$f$</span> a smooth non-linear function and <span>$x \in \mathbb{R}^n$</span>.</p><p>MPR2 dynamically adapts the floating point formats used for objective and gradient evaluations so that the convergence is guaranteed in spite of evaluation errors due to finite-precision computations and over/underflow are avoided.</p><p>MPR2 relies on <code>FPMPNLPModel</code> structure (see documentation) to evaluate the objective and gradient with multiple floating point format and control the evaluation errors.</p><h1 id="How-to-Run"><a class="docs-heading-anchor" href="#How-to-Run">How to Run</a><a id="How-to-Run-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Run" title="Permalink"></a></h1><p>MPR2 algorithm is run in the same fashion than solvers from <a href="https://github.com/JuliaSmoothOptimizers/JSOSolvers.jl"><code>JSOSolvers.jl</code></a> package, but uses a <code>FPMPNLPModel</code> structure which is a multi-precision extension of <code>NLPModel</code> structure to multi-precision.</p><p>MPR2 algorithm is run with <code>MPR2()</code> function, which returns a <a href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl"><code>GenericExecutionStat</code></a> structure containing useful information (nb. of iteration, termination status, etc.). The number of evaluations can be access via the <code>FPMPNLPModel</code> structure (see <code>FPMPNLPModel</code> and <code>MPCounters</code> documentation).</p><pre><code class="language-julia hljs">using MultiPrecisionR2

T = [Float32,Float64] # floating point formats used for evaluation
f(x) = sum(x.^2) # objective function
n = 100 # problem dimension
x0 = ones(n) # initial solution
mpnlp = FPMPNLPModel(f,x0,T) # creates a multi-precision model of the problem
stats = MPR2(mpnlp)
println(&quot;Objective was evaluated $(neval_obj(mpnlp,Float32)) times with Float32 and $(neval_obj(mpnlp,Float64)) times with Float64&quot;)
println(&quot;Gradient was evaluated $(neval_grad(mpnlp,Float32)) times with Float32 and $(neval_grad(mpnlp,Float64)) times with Float64&quot;)</code></pre><p>For advanced use, see <code>MPR2Solver</code> solver structure and <code>solve!()</code> functions.</p><h1 id="Solver-Options"><a class="docs-heading-anchor" href="#Solver-Options">Solver Options</a><a id="Solver-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Options" title="Permalink"></a></h1><p>Some parameters of the algorithm can be given as keyword arguments of <code>MPR2()</code>. The type parameters are <code>S::AbstractVector</code>, <code>H::AbstractFloat</code>, <code>T::DataType</code>, <code>E::DataType</code>.</p><p><code>MPR2(mpnlp::FPMPNLPModel; kwargs...)</code></p><table><tr><th style="text-align: right">kwarg</th><th style="text-align: right">description</th></tr><tr><td style="text-align: right"><code>x₀::S = MPnlp.Model.meta.x0</code></td><td style="text-align: right">initial guess</td></tr><tr><td style="text-align: right"><code>par::MPR2Params = MPR2Params(MPnlp.FPList[1],H)</code></td><td style="text-align: right">MPR2 parameters, see <code>MPR2Params</code> for details</td></tr><tr><td style="text-align: right"><code>atol::H = H(sqrt(eps(T)))</code></td><td style="text-align: right">absolute tolerance on first order criterion</td></tr><tr><td style="text-align: right"><code>rtol::H = H(sqrt(eps(T)))</code></td><td style="text-align: right">relative tolerance on first order criterion</td></tr><tr><td style="text-align: right"><code>max_eval::Int = -1</code></td><td style="text-align: right">maximum number of evaluation of the objective function.</td></tr><tr><td style="text-align: right"><code>max_iter::Int = 1000</code></td><td style="text-align: right">maximum number of iteration allowed</td></tr><tr><td style="text-align: right"><code>σmin::T = sqrt(T(MPnlp.EpsList[end]))</code></td><td style="text-align: right">minimal value for regularization parameter. Value must be representable in any of the floating point formats of MPnlp.</td></tr><tr><td style="text-align: right"><code>verbose::Int=0</code></td><td style="text-align: right">display iteration information if &gt; 0</td></tr><tr><td style="text-align: right"><code>e::E</code></td><td style="text-align: right">user defined structure, used as argument for <code>compute_f_at_x!</code>, <code>compute_f_at_c!</code>, <code>compute_g!</code> and <code>recompute_g!</code> callback functions.</td></tr><tr><td style="text-align: right"><code>compute_f_at_x!</code></td><td style="text-align: right">callback function to select precision and compute objective value and error bound at the current point. Allows to reevaluate the objective at x if more precision is needed.</td></tr><tr><td style="text-align: right"><code>compute_f_at_c!</code></td><td style="text-align: right">callback function to select precision and compute objective value and error bound at candidate.</td></tr><tr><td style="text-align: right"><code>compute_g!</code></td><td style="text-align: right">callback function to select precision and compute gradient value and error bound. Called at the end of main loop.</td></tr><tr><td style="text-align: right"><code>recompute_g!</code></td><td style="text-align: right">callback function to select precision and recompute gradient value if more precision is needed. Called after step, candidate and model decrease computation in main loop.</td></tr><tr><td style="text-align: right"><code>selectPic!</code></td><td style="text-align: right">callback function to select FP format of <code>c</code> at the next iteration</td></tr></table><h1 id="Choosing-MPR2-Parameters"><a class="docs-heading-anchor" href="#Choosing-MPR2-Parameters">Choosing MPR2 Parameters</a><a id="Choosing-MPR2-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-MPR2-Parameters" title="Permalink"></a></h1><p>MPR2 algorithm parameters for error tolerance and step acceptance can be given as <code>par::MPR2Params</code> keyword argument. These parameters correspond to <code>MPR2Params</code> fields, with type parameters <code>H::AbstractFloat</code> and <code>L::AbstractFloat</code>.</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th><th style="text-align: right">Default value</th></tr><tr><td style="text-align: right"><code>η₀::H</code></td><td style="text-align: right"><code>0.01</code></td><td style="text-align: right">controls objective function error tolerance, convergence condition is ωf ≤ η₀ ΔT (see <code>FPMPNLPModel</code> for details on ωf)</td></tr><tr><td style="text-align: right"><code>η₁::H</code></td><td style="text-align: right"><code>0.02</code></td><td style="text-align: right">step successful if ρ ≥ η₁ (update incumbent)</td></tr><tr><td style="text-align: right"><code>η₂::H</code></td><td style="text-align: right"><code>0.95</code></td><td style="text-align: right">step very successful if ρ ≥ η₂ (decrease σ ⟹ increase step length)</td></tr><tr><td style="text-align: right"><code>κₘ::H</code></td><td style="text-align: right"><code>0.02</code></td><td style="text-align: right">tolerance on gradient evaluation error, μ ≤ κₘ (see <code>computeMu</code>)</td></tr><tr><td style="text-align: right"><code>γ₁::L</code></td><td style="text-align: right"><code>2^(-2)</code> σk+1 = σk * γ₁ if ρ ≥ η₂</td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>γ₂::L</code></td><td style="text-align: right"><code>2</code></td><td style="text-align: right">σk+1 = σk * γ₂ if ρ &lt; η₁</td></tr></table><p>These parameters must satisfy some conditions, see <code>MPR2Params</code> for details. These conditions can be checked with <code>CheckMPR2ParamConditions()</code> function.</p><h1 id="Evaluation-Error-Mode"><a class="docs-heading-anchor" href="#Evaluation-Error-Mode">Evaluation Error Mode</a><a id="Evaluation-Error-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Error-Mode" title="Permalink"></a></h1><p>MPR2 convergence is ensured by taking into account objective and gradient evaluation errors. These errors can be evaluated with interval arithmetic of based on relative error assumption. The error evaluation mode is chosen upon the <code>FPMPNLPModel</code> instanciation given as argument of <code>MPR2()</code>. Evaluating the objective/gradient and the error is done with the interfaces provided in <code>MPNLPModels.jl</code>, see <code>FPMPNLPModel</code> documentation. </p><h1 id="Callbacks-for-Personalized-Implementation"><a class="docs-heading-anchor" href="#Callbacks-for-Personalized-Implementation">Callbacks for Personalized Implementation</a><a id="Callbacks-for-Personalized-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks-for-Personalized-Implementation" title="Permalink"></a></h1><p><code>MPR2()</code> allows the user to define its own strategies for evaluation FP formats selection and error handling for objective and gradient evaluations. This can be done by providing the callbacks <code>compute_f_at_x!</code>, <code>compute_f_at_c!</code>, <code>compute_g!</code>, <code>recompute_g!</code> and <code>selectPic!</code>. See &quot;MPR2 advanced use&quot; tutorial for usage. </p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 26 July 2023 20:51">Wednesday 26 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
